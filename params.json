{
  "name": "Json-validator",
  "tagline": "This is a small PHP library useful to validate JSON structures.",
  "body": "# JSON Validator\r\n\r\n[![Build Status](https://travis-ci.org/daemonraco/json-validator.svg?branch=master)](https://travis-ci.org/daemonraco/json-validator)\r\n\r\n## What is it?\r\nThis is a small PHP library useful to validate JSON structures.\r\nThis is similar to [DTD](https://en.wikipedia.org/wiki/Document_type_definition)\r\nfiles for XML.\r\n\r\n## How to use it\r\nHere is an example of how to validate a JSON file stored at\r\n`/path/to/json-to-validate.json`:\r\n```php\r\n<?php\r\n// Loading the library.\r\nrequire_once '/path/to/library/json-validator.php';\r\n// Fetching a validator.\r\n$validator = JSONValidator::LoadFromFile('/path/to/json-specification.json');\r\n// Validating...\r\n$check = $validator->validatePath('/path/to/json-to-validate.json', $info);\r\n// Showing results.\r\nvar_dump($check, $info);\r\n```\r\nYou're probably wondering about `/path/to/json-specification.json` and what's\r\ninside it, well, we'll talk about it in the next section.\r\n\r\n## How to specify rules\r\nLet's say you have a JSON file like this one:\r\n```json\r\n[\r\n\t{\r\n\t\t\"name\": \"Flour\",\r\n\t\t\"description\": \"Useful to make bread\",\r\n\t\t\"price\": 1.2,\r\n\t\t\"type\": \"comestible\",\r\n\t\t\"status\": \"available\"\r\n\t}, {\r\n\t\t\"name\": \"Egg\",\r\n\t\t\"price\": 0.73,\r\n\t\t\"type\": \"comestible\",\r\n\t\t\"status\": \"soldout\",\r\n\t\t\"notes\": \"we've run out of these last week\"\r\n\t}\r\n]\r\n```\r\nIf you want to make sure the it has the right structure you may specify a\r\nstructure like this one:\r\n```json\r\n{\r\n\t\"types\": {\r\n\t\t\"Products\": \"Product[]\",\r\n\t\t\"Product\": {\r\n\t\t\t\"name\": \"+string\",\r\n\t\t\t\"description\": \"Description\",\r\n\t\t\t\"price\": \"+float\",\r\n\t\t\t\"type\": \"+string\",\r\n\t\t\t\"status\": \"ProductStatus\",\r\n\t\t\t\"notes\": \"Notes\"\r\n\t\t},\r\n\t\t\"ProductStatus\": \"/^(available|soldout)$/\",\r\n\t\t\"Notes\": [\"string\", \"object\"],\r\n\t\t\"Description\": \"string\"\r\n\t},\r\n\t\"root\": \"+Products\"\r\n}\r\n```\r\nyes, I know, it's confusing, let's explain it.\r\n\r\n### Types of types\r\nIn you specification, the field `types` contains the list of all non primitive\r\ntypes.\r\nEach entry is a type name associated with it's actual definition that can be one\r\nthese types:\r\n\r\n* _Alias_\r\n* _List of types_\r\n* _Structure_\r\n* _Regular expression_\r\n\r\n#### Alias\r\nAn alias time is just a redefinition of another type, or even expansion of another\r\ntype to convert it into a list of it.\r\nI our example, `Products` is not only defined as an alias of `Product`, but a list\r\nof entries that must follow the specification for `Product`.\r\n\r\n`Description` is also an alias.\r\n\r\n#### List of types\r\nIn our example, the type `Notes` is one of these.\r\nBasically it tell us that any field of type `Notes` may be a `string` or an\r\n`object`, but no other.\r\n\r\n#### Structure\r\nThis is perhaps the complex one.\r\nIn it, each entry is a name of a field to look for associated with the type it\r\nmust follow.\r\nIn our example, `Product` is of this kind and it specifies six field, four of\r\nprimitive types and two of types we listed in our configuration.\r\n\r\nHere, if you look closely, at least three fields have a plus sign (`+`) before its\r\ntype name, that flag indicates that it's a required field meaning the validation\r\nwill fail if not present.\r\n\r\n#### Regular expression\r\nThe magical way is to specify a type as a [_regular\r\nexpression_](https://en.wikipedia.org/wiki/Regular_expression).\r\nAs you probably guest already, it will take a field and validate it against the\r\nexpression.\r\n\r\nIn our example, this means that product status can either be `available` or\r\n`soldout`.\r\n\r\n### Primitive types\r\nBy default, this library supports a set of type call primitives that perform\r\nsimple validations.\r\nThese types are:\r\n\r\n* `array`: List of items that can be of any type.\r\n* `boolean`: Either `true` or `false`.\r\n* `float`: Floating point number.\r\n* `int`: An integer.\r\n* `mixed`: Any type.\r\n* `object`: Structured type.\r\n* `string`: A simple string.\r\n\r\n### Containers\r\nPreviously we mention the type `Products` and that it's an alias representing a\r\nlist of products, _but how?_\r\n\r\nWhen we specify a type as an alias we may use `[]` or `{}` at the end of the\r\ntype's name to indicate that it's a container of.\r\nWhen using `[]` we are saying that it's a simple list of items and `{}` means that\r\nit's an associative list.\r\n\r\n### Root type\r\nIf out look at the end of our example, there's a field called `root`, this will be\r\nthe first type to check.\r\nEverything has to start somewhere, right? :D\r\n\r\n## Policies\r\nIf you need to apply policies to your types, follow [this link](docs/policies.md)\r\nto obtain more information.\r\n\r\n## Online\r\nIf you want to try your configurations, visit our online validator at:\r\n\r\n* http://json-validator.daemonraco.com/\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}